# Git運用ルール

この文書は、これまでの会話で整理した「ブランチの役割」「検証→本番リリースの流れ」「コミットの扱い」を、1つにまとめたものです。

## 用語の整理

- **ブランチ戦略**: どのブランチを用意し、どこへどうマージするか（流れ・役割）
- **リリース戦略**: いつ・どの単位で・どう検証して出すか（頻度・段階・昇格）
- **コミット方針**: コミット粒度、メッセージ、squash の有無、履歴を資産として扱うか

## 前提（今回の要件）

- `staging` へ反映することが「検証環境へのリリース」に相当する
- 検証で問題なければ、そのまま本番へ昇格してリリースする
- リリースには複数のバグ修正・タスクが含まれることがある
- それでも **バグ/タスク単位で revert できる**ことを重視する

## 推奨のブランチ構成（デプロイ用と統合用を分ける）

`staging` が「リリース＝デプロイ」なので、変更の受け皿（統合用）を別に用意します。

- `production`（または `main`）: 本番用
- `staging`: 検証用（検証環境へデプロイされる）
- `integration`（または `develop`/`dev`）: 統合用（**デプロイしない**）

ブランチ名は慣習に合わせてよく、`main` である必要はありません（役割が一貫していればOK）。

## 推奨フロー（バグ/タスクを揃えてから staging へ出す）

1. **バグ/タスクごとに作業ブランチを作る**
   - 例: `fix/123-login`, `feat/456-export`
   - 作業ブランチ内のコミットは複数でもよい（WIP でもよい）
2. **作業ブランチ → `integration` に PR**
   - `integration` は統合専用なので、要件が揃っていなくても先に取り込める
3. **リリース対象が揃ったら `integration` → `staging` に「リリースPR」**
   - ここが「検証環境へのリリース」
4. 検証OKなら **`staging` → `production`（または `main`）へマージ**
   - ここが「本番リリース」
   - リリースの区切りは「マージコミット」か「タグ」で残すと追跡しやすい

## コミット方針（バグ/タスク単位で revert したい場合）

### 方針の結論

- **バグ/タスク単位で revert したい**なら、最終的に `staging` / `production` 上で「バグ/タスクが 1コミットにまとまっている」状態が扱いやすいです。

### 具体策（作業ブランチは自由、取り込み時に 1コミット化）

- 作業ブランチは複数コミットOK
- **`integration` へ取り込むときに squash**して「1PR（=1バグ/タスク）= 1コミット」に揃える
  - これにより、後から `staging`/`production` で **そのコミットだけ revert**しやすくなる

補足:
- squash を採用する場合、作業ブランチ上の「こだわったコミット履歴」は `production` には残りません（残す価値が必要なら squash しない運用に寄せます）。

## 共有ブランチと rebase（注意）

- 複数人が同じブランチを共有して作業している場合、`rebase` は履歴を書き換えるため運用事故が起きやすいです（強制 push が絡むため）。
- 共有ブランチ前提なら、基本は「作業ブランチは個人のもの」「統合は PR」を前提にし、どうしても共有が必要な場合は merge ベースに寄せるのが安全です。

## マージ方式の目安（CodeCommit / GitHub どちらでも使える考え方）

- **PR単位で1コミットにしたい**（=バグ/タスク単位の revert を簡単にしたい）
  - → PR取り込みは **squash** が相性が良い
- **コミット履歴そのものを資産として残したい**
  - → **squash しない**（rebase and merge / merge commit など）
